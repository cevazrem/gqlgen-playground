// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"gqlgen-playground/internal/pkg/model"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/google/uuid"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AggregationResult struct {
		Rows func(childComplexity int) int
	}

	AggregationRow struct {
		Keys    func(childComplexity int) int
		Metrics func(childComplexity int) int
	}

	Comment struct {
		Author    func(childComplexity int) int
		Content   func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Replies   func(childComplexity int, limit *int32, offset *int32) int
	}

	CreateUserPayload struct {
		User func(childComplexity int) int
	}

	Mutation struct {
		CreateUser func(childComplexity int, input model.CreateUserInput) int
	}

	Post struct {
		Author   func(childComplexity int) int
		Comments func(childComplexity int, limit *int32, offset *int32) int
		Content  func(childComplexity int) int
		ID       func(childComplexity int) int
		Title    func(childComplexity int) int
	}

	Query struct {
		Comments             func(childComplexity int, postID uuid.UUID, limit *int32, offset *int32) int
		ExpensiveAggregation func(childComplexity int, input model.ExpensiveInput) int
		Me                   func(childComplexity int) int
		Post                 func(childComplexity int, id uuid.UUID) int
		Posts                func(childComplexity int, limit *int32, offset *int32) int
		SearchUsers          func(childComplexity int, filter *model.UserFilter, limit *int32) int
		UserByID             func(childComplexity int, id uuid.UUID) int
		Users                func(childComplexity int, limit *int32, offset *int32) int
	}

	User struct {
		CreatedAt func(childComplexity int) int
		Email     func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AggregationResult.rows":
		if e.complexity.AggregationResult.Rows == nil {
			break
		}

		return e.complexity.AggregationResult.Rows(childComplexity), true

	case "AggregationRow.keys":
		if e.complexity.AggregationRow.Keys == nil {
			break
		}

		return e.complexity.AggregationRow.Keys(childComplexity), true

	case "AggregationRow.metrics":
		if e.complexity.AggregationRow.Metrics == nil {
			break
		}

		return e.complexity.AggregationRow.Metrics(childComplexity), true

	case "Comment.author":
		if e.complexity.Comment.Author == nil {
			break
		}

		return e.complexity.Comment.Author(childComplexity), true

	case "Comment.content":
		if e.complexity.Comment.Content == nil {
			break
		}

		return e.complexity.Comment.Content(childComplexity), true

	case "Comment.createdAt":
		if e.complexity.Comment.CreatedAt == nil {
			break
		}

		return e.complexity.Comment.CreatedAt(childComplexity), true

	case "Comment.id":
		if e.complexity.Comment.ID == nil {
			break
		}

		return e.complexity.Comment.ID(childComplexity), true

	case "Comment.replies":
		if e.complexity.Comment.Replies == nil {
			break
		}

		args, err := ec.field_Comment_replies_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Comment.Replies(childComplexity, args["limit"].(*int32), args["offset"].(*int32)), true

	case "CreateUserPayload.user":
		if e.complexity.CreateUserPayload.User == nil {
			break
		}

		return e.complexity.CreateUserPayload.User(childComplexity), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(model.CreateUserInput)), true

	case "Post.author":
		if e.complexity.Post.Author == nil {
			break
		}

		return e.complexity.Post.Author(childComplexity), true

	case "Post.comments":
		if e.complexity.Post.Comments == nil {
			break
		}

		args, err := ec.field_Post_comments_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Post.Comments(childComplexity, args["limit"].(*int32), args["offset"].(*int32)), true

	case "Post.content":
		if e.complexity.Post.Content == nil {
			break
		}

		return e.complexity.Post.Content(childComplexity), true

	case "Post.id":
		if e.complexity.Post.ID == nil {
			break
		}

		return e.complexity.Post.ID(childComplexity), true

	case "Post.title":
		if e.complexity.Post.Title == nil {
			break
		}

		return e.complexity.Post.Title(childComplexity), true

	case "Query.comments":
		if e.complexity.Query.Comments == nil {
			break
		}

		args, err := ec.field_Query_comments_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Comments(childComplexity, args["postID"].(uuid.UUID), args["limit"].(*int32), args["offset"].(*int32)), true

	case "Query.expensiveAggregation":
		if e.complexity.Query.ExpensiveAggregation == nil {
			break
		}

		args, err := ec.field_Query_expensiveAggregation_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ExpensiveAggregation(childComplexity, args["input"].(model.ExpensiveInput)), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.post":
		if e.complexity.Query.Post == nil {
			break
		}

		args, err := ec.field_Query_post_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Post(childComplexity, args["id"].(uuid.UUID)), true

	case "Query.posts":
		if e.complexity.Query.Posts == nil {
			break
		}

		args, err := ec.field_Query_posts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Posts(childComplexity, args["limit"].(*int32), args["offset"].(*int32)), true

	case "Query.searchUsers":
		if e.complexity.Query.SearchUsers == nil {
			break
		}

		args, err := ec.field_Query_searchUsers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchUsers(childComplexity, args["filter"].(*model.UserFilter), args["limit"].(*int32)), true

	case "Query.userByID":
		if e.complexity.Query.UserByID == nil {
			break
		}

		args, err := ec.field_Query_userByID_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserByID(childComplexity, args["id"].(uuid.UUID)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["limit"].(*int32), args["offset"].(*int32)), true

	case "User.created_at":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAggregationFilterGroupInput,
		ec.unmarshalInputAggregationMetricInput,
		ec.unmarshalInputAggregationPredicateInput,
		ec.unmarshalInputCreateUserInput,
		ec.unmarshalInputExpensiveInput,
		ec.unmarshalInputTimeRangeInput,
		ec.unmarshalInputUserFilter,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../../api/graphql/enums/aggregationField.graphql", Input: `enum AggregationField {
    USER
    POST
    COMMENT
    DAY
    HOUR
}`, BuiltIn: false},
	{Name: "../../../../api/graphql/enums/comparisonOp.graphql", Input: `enum ComparisonOp {
    EQ
    NEQ
    GT
    GTE
    LT
    LTE
    IN
    NOT_IN
}`, BuiltIn: false},
	{Name: "../../../../api/graphql/enums/metricOp.graphql", Input: `enum MetricOp {
    COUNT
    SUM
    AVG
}`, BuiltIn: false},
	{Name: "../../../../api/graphql/mutation/user.mutation.graphql", Input: `extend type Mutation {
    createUser(input: CreateUserInput!): CreateUserPayload!
}

input CreateUserInput {
    name: String!
}

type CreateUserPayload {
    user: User!
}`, BuiltIn: false},
	{Name: "../../../../api/graphql/query/user.query.graphql", Input: `extend type Query {
    # Базовый пользователь, чтобы было с чего начинать запросы
    me: User!

    userByID(id: UUID!): User
    post(id: UUID!): Post

    # Списки — для алиасов и N+1
    users(limit: Int = 10, offset: Int = 0): [User!]!
    posts(limit: Int = 10, offset: Int = 0): [Post!]!
    comments(postID: UUID!, limit: Int = 50, offset: Int = 0): [Comment!]!

    # Сложные аргументы → DoS по аргументам
    searchUsers(filter: UserFilter, limit: Int = 100): [User!]!

    # "Дорогая" агрегация
    expensiveAggregation(input: ExpensiveInput!): AggregationResult!
}

input UserFilter {
    and: [UserFilter!]
    or: [UserFilter!]

    nameContains: String
    emailDomainIn: [String!]
    minPosts: Int
}

input ExpensiveInput {
    groupBy: [AggregationField!]!
    metrics: [AggregationMetricInput!]!
    filters: [AggregationFilterGroupInput!]
    timeRange: TimeRangeInput
}

input AggregationMetricInput {
    field: AggregationField!
    operation: MetricOp!
}

input AggregationFilterGroupInput {
    and: [AggregationFilterGroupInput!]
    or: [AggregationFilterGroupInput!]
    predicate: AggregationPredicateInput
}

input AggregationPredicateInput {
    field: AggregationField!
    op: ComparisonOp!
    stringValue: String
    intValue: Int
    floatValue: Float
}

input TimeRangeInput {
    from: Time!
    to: Time!
}

type AggregationResult {
    rows: [AggregationRow!]!
}

type AggregationRow {
    keys: [String!]!
    metrics: [Float!]!
}`, BuiltIn: false},
	{Name: "../../../../api/graphql/schema/scalar.graphql", Input: `scalar UUID
scalar Time`, BuiltIn: false},
	{Name: "../../../../api/graphql/schema/schema.graphql", Input: `schema {
    query: Query
    mutation: Mutation
}

type Query

type Mutation`, BuiltIn: false},
	{Name: "../../../../api/graphql/types/comment.graphql", Input: `type Comment {
    id: UUID!
    author: User!
    content: String!
    createdAt: Time!
    # Рекурсивный тип -> DoS по глубине
    replies(limit: Int = 50, offset: Int = 0): [Comment!]!
}`, BuiltIn: false},
	{Name: "../../../../api/graphql/types/post.graphql", Input: `type Post {
    id: UUID!
    title: String!
    content: String!
    author: User!
    comments(limit: Int = 50, offset: Int = 0): [Comment!]!
}`, BuiltIn: false},
	{Name: "../../../../api/graphql/types/user.graphql", Input: `type User {
    id: UUID!
    created_at: Time!
    name: String!
    email: String!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
