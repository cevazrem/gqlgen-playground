// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/google/uuid"
)

type AggregationFilterGroupInput struct {
	And       []*AggregationFilterGroupInput `json:"and,omitempty"`
	Or        []*AggregationFilterGroupInput `json:"or,omitempty"`
	Predicate *AggregationPredicateInput     `json:"predicate,omitempty"`
}

type AggregationMetricInput struct {
	Field     AggregationField `json:"field"`
	Operation MetricOp         `json:"operation"`
}

type AggregationPredicateInput struct {
	Field       AggregationField `json:"field"`
	Op          ComparisonOp     `json:"op"`
	StringValue *string          `json:"stringValue,omitempty"`
	IntValue    *int32           `json:"intValue,omitempty"`
	FloatValue  *float64         `json:"floatValue,omitempty"`
}

type AggregationResult struct {
	Rows []*AggregationRow `json:"rows"`
}

type AggregationRow struct {
	Keys    []string  `json:"keys"`
	Metrics []float64 `json:"metrics"`
}

type Comment struct {
	ID        uuid.UUID  `json:"id"`
	Author    *User      `json:"author"`
	Content   string     `json:"content"`
	CreatedAt time.Time  `json:"createdAt"`
	Replies   []*Comment `json:"replies"`
}

type CreateUserInput struct {
	Name string `json:"name"`
}

type CreateUserPayload struct {
	User *User `json:"user"`
}

type ExpensiveInput struct {
	GroupBy   []AggregationField             `json:"groupBy"`
	Metrics   []*AggregationMetricInput      `json:"metrics"`
	Filters   []*AggregationFilterGroupInput `json:"filters,omitempty"`
	TimeRange *TimeRangeInput                `json:"timeRange,omitempty"`
}

type Mutation struct {
}

type Post struct {
	ID       uuid.UUID  `json:"id"`
	Title    string     `json:"title"`
	Content  string     `json:"content"`
	Author   *User      `json:"author"`
	Comments []*Comment `json:"comments"`
}

type Query struct {
}

type TimeRangeInput struct {
	From time.Time `json:"from"`
	To   time.Time `json:"to"`
}

type User struct {
	ID        uuid.UUID `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	Name      string    `json:"name"`
	Email     string    `json:"email"`
}

type UserFilter struct {
	And           []*UserFilter `json:"and,omitempty"`
	Or            []*UserFilter `json:"or,omitempty"`
	NameContains  *string       `json:"nameContains,omitempty"`
	EmailDomainIn []string      `json:"emailDomainIn,omitempty"`
	MinPosts      *int32        `json:"minPosts,omitempty"`
}

type AggregationField string

const (
	AggregationFieldUser    AggregationField = "USER"
	AggregationFieldPost    AggregationField = "POST"
	AggregationFieldComment AggregationField = "COMMENT"
	AggregationFieldDay     AggregationField = "DAY"
	AggregationFieldHour    AggregationField = "HOUR"
)

var AllAggregationField = []AggregationField{
	AggregationFieldUser,
	AggregationFieldPost,
	AggregationFieldComment,
	AggregationFieldDay,
	AggregationFieldHour,
}

func (e AggregationField) IsValid() bool {
	switch e {
	case AggregationFieldUser, AggregationFieldPost, AggregationFieldComment, AggregationFieldDay, AggregationFieldHour:
		return true
	}
	return false
}

func (e AggregationField) String() string {
	return string(e)
}

func (e *AggregationField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AggregationField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AggregationField", str)
	}
	return nil
}

func (e AggregationField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AggregationField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AggregationField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ComparisonOp string

const (
	ComparisonOpEq    ComparisonOp = "EQ"
	ComparisonOpNeq   ComparisonOp = "NEQ"
	ComparisonOpGt    ComparisonOp = "GT"
	ComparisonOpGte   ComparisonOp = "GTE"
	ComparisonOpLt    ComparisonOp = "LT"
	ComparisonOpLte   ComparisonOp = "LTE"
	ComparisonOpIn    ComparisonOp = "IN"
	ComparisonOpNotIn ComparisonOp = "NOT_IN"
)

var AllComparisonOp = []ComparisonOp{
	ComparisonOpEq,
	ComparisonOpNeq,
	ComparisonOpGt,
	ComparisonOpGte,
	ComparisonOpLt,
	ComparisonOpLte,
	ComparisonOpIn,
	ComparisonOpNotIn,
}

func (e ComparisonOp) IsValid() bool {
	switch e {
	case ComparisonOpEq, ComparisonOpNeq, ComparisonOpGt, ComparisonOpGte, ComparisonOpLt, ComparisonOpLte, ComparisonOpIn, ComparisonOpNotIn:
		return true
	}
	return false
}

func (e ComparisonOp) String() string {
	return string(e)
}

func (e *ComparisonOp) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ComparisonOp(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ComparisonOp", str)
	}
	return nil
}

func (e ComparisonOp) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ComparisonOp) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ComparisonOp) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MetricOp string

const (
	MetricOpCount MetricOp = "COUNT"
	MetricOpSum   MetricOp = "SUM"
	MetricOpAvg   MetricOp = "AVG"
)

var AllMetricOp = []MetricOp{
	MetricOpCount,
	MetricOpSum,
	MetricOpAvg,
}

func (e MetricOp) IsValid() bool {
	switch e {
	case MetricOpCount, MetricOpSum, MetricOpAvg:
		return true
	}
	return false
}

func (e MetricOp) String() string {
	return string(e)
}

func (e *MetricOp) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetricOp(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetricOp", str)
	}
	return nil
}

func (e MetricOp) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MetricOp) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MetricOp) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
